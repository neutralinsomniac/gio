// SPDX-License-Identifier: Unlicense OR MIT

// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

// This program generates shader variants for
// multiple GPU backends (OpenGL ES, Direct3D 11...)
// from a single source.

type shaderArgs struct {
	FetchColorExpr string
	Header         string
}

func main() {
	if err := generate(); err != nil {
		fmt.Fprintf(os.Stderr, "gpu generate: %v\n", err)
		os.Exit(1)
	}
}

func generate() error {
	tmp, err := ioutil.TempDir("", "gpu-generate")
	if err != nil {
		return err
	}
	defer os.RemoveAll(tmp)
	glslcc, err := exec.LookPath("glslcc")
	if err != nil {
		return err
	}
	fxc, err := exec.LookPath("fxc")
	if err != nil {
		return err
	}
	shaders, err := filepath.Glob("shaders/*")
	if err != nil {
		return err
	}
	var out bytes.Buffer
	out.WriteString("// Code generated by build.go. DO NOT EDIT.\n\n")
	out.WriteString("package gpu\n\n")

	out.WriteString("var (\n")

	for _, shader := range shaders {
		const nvariants = 2
		var variants [nvariants]struct {
			gles2   string
			hlslSrc string
			hlsl    []byte
		}
		args := [nvariants]shaderArgs{
			{
				FetchColorExpr: `color.color`,
				Header:         `layout(binding=0) uniform Color { vec4 color; } color;`,
			},
			{
				FetchColorExpr: `texture(tex, vUV)`,
				Header:         `layout(binding=0) uniform sampler2D tex;`,
			},
		}
		for i := range args {
			gles2, err := convertShader(tmp, glslcc, shader, "gles", "100", &args[i])
			if err != nil {
				return err
			}
			hlsl, err := convertShader(tmp, glslcc, shader, "hlsl", "40", &args[i])
			if err != nil {
				return err
			}
			var hlslProf string
			switch filepath.Ext(shader) {
			case ".frag":
				hlslProf = "ps"
			case ".vert":
				hlslProf = "vs"
			default:
				return fmt.Errorf("unrecognized shader type %s", shader)
			}
			hlslc, err := compileHLSL(tmp, fxc, hlsl, "main", hlslProf+"_4_0")
			if err != nil {
				return err
			}
			variants[i].gles2 = gles2
			variants[i].hlslSrc = hlsl
			variants[i].hlsl = hlslc
		}
		name := filepath.Base(shader)
		name = strings.ReplaceAll(name, ".", "_")
		fmt.Fprintf(&out, "\tshader_%s = ", name)
		// If the shader don't use the variant arguments, output
		// only a single version.
		multiVariant := variants[0].gles2 != variants[1].gles2
		if multiVariant {
			fmt.Fprintf(&out, "[...]ShaderSources{\n")
		}
		for _, src := range variants {
			fmt.Fprintf(&out, "ShaderSources{\n")
			fmt.Fprintf(&out, "GLES2: %#v,\n", src.gles2)
			fmt.Fprintf(&out, "/*\n%s\n*/\n", src.hlslSrc)
			fmt.Fprintf(&out, "HLSL: %#v,\n", src.hlsl)
			fmt.Fprintf(&out, "}")
			if multiVariant {
				fmt.Fprintf(&out, ",")
			}
			fmt.Fprintf(&out, "\n")
			if !multiVariant {
				break
			}
		}
		if multiVariant {
			fmt.Fprintf(&out, "}\n")
		}
	}
	out.WriteString(")")
	gosrc, err := format.Source(out.Bytes())
	if err != nil {
		return fmt.Errorf("shader.go: %v", err)
	}
	return ioutil.WriteFile("shaders.go", gosrc, 0644)
}

func compileHLSL(tmp, fxc, src, entry, profile string) ([]byte, error) {
	tmpfile := filepath.Join(tmp, "shader.hlsl")
	if err := ioutil.WriteFile(tmpfile, []byte(src), 0644); err != nil {
		return nil, err
	}
	outFile := filepath.Join(tmp, "shader.bin")
	cmd := exec.Command(fxc,
		"/T", profile,
		"/E", entry,
		"/nologo",
		"/Fo", outFile,
		tmpfile,
	)
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return nil, err
	}
	return ioutil.ReadFile(outFile)
}

func convertShader(tmp, glslcc, path, lang, profile string, args *shaderArgs) (string, error) {
	shaderTmpl, err := template.ParseFiles(path)
	if err != nil {
		return "", err
	}
	var buf bytes.Buffer
	if err := shaderTmpl.Execute(&buf, args); err != nil {
		return "", err
	}
	tmppath := filepath.Join(tmp, filepath.Base(path))
	if err := ioutil.WriteFile(tmppath, buf.Bytes(), 0644); err != nil {
		return "", err
	}
	defer os.Remove(tmppath)
	var progFlag string
	var progSuffix string
	switch filepath.Ext(path) {
	case ".vert":
		progFlag = "--vert"
		progSuffix = "vs"
	case ".frag":
		progFlag = "--frag"
		progSuffix = "fs"
	default:
		return "", fmt.Errorf("unrecognized shader type: %s", path)
	}
	cmd := exec.Command(glslcc,
		"--silent",
		"--optimize",
		"--output", filepath.Join(tmp, "shader"),
		"--lang", lang,
		"--profile", profile,
		progFlag, tmppath,
	)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("%s: %v", path, err)
	}
	f, err := os.Open(filepath.Join(tmp, "shader_"+progSuffix))
	if err != nil {
		return "", err
	}
	defer f.Close()
	defer os.Remove(f.Name())
	src, err := ioutil.ReadAll(f)
	if err != nil {
		return "", err
	}
	return string(src), nil
}
